name: Deploy Backend to EC2

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
        
    - name: Install dependencies
      run: |
        go mod download
        go get -u github.com/stretchr/testify/assert
        
    - name: Run tests
      run: |
        echo "üß™ Running all tests..."
        go test -v ./...
        
    - name: Run tests with coverage
      run: |
        echo "üìä Running tests with coverage..."
        go test -coverprofile=coverage.out ./...
        go tool cover -func=coverage.out
        
    - name: Check coverage threshold
      run: |
        echo "üìà Checking coverage threshold..."
        coverage=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
        echo "Total coverage: $coverage%"
        if (( $(echo "$coverage < 10" | bc -l) )); then
          echo "‚ö†Ô∏è Warning: Coverage is below 10%"
        fi
        
    - name: Run linting
      uses: golangci/golangci-lint-action@v4
      with:
        version: latest
        args: --out-format=colored-line-number
        skip-cache: true

  deploy-backend:
    runs-on: ubuntu-latest
    environment: prod
    needs: test  # Only deploy if tests pass
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-2
        
    - name: Set up environment variables
      run: |
        echo "Setting up GCP environment variables..."
        echo "GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}" >> $GITHUB_ENV
        echo "GCP_PRIVATE_KEY_ID=${{ secrets.GCP_PRIVATE_KEY_ID }}" >> $GITHUB_ENV
        echo "GCP_PRIVATE_KEY='${{ secrets.GCP_PRIVATE_KEY }}'" >> $GITHUB_ENV
        echo "GCP_CLIENT_EMAIL=${{ secrets.GCP_CLIENT_EMAIL }}" >> $GITHUB_ENV
        echo "GCP_CLIENT_ID=${{ secrets.GCP_CLIENT_ID }}" >> $GITHUB_ENV
        echo "GCP_CLIENT_X509_CERT_URL=${{ secrets.GCP_CLIENT_X509_CERT_URL }}" >> $GITHUB_ENV
        echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> $GITHUB_ENV
        
    - name: Deploy Backend to EC2
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.BACKEND_EC2_HOST }}
        username: ec2-user
        key: ${{ secrets.BACKEND_EC2_SSH_KEY }}
        script: |
          set -Eeuo pipefail
          trap 'echo "‚ùå Error on line $LINENO"; exit 1' ERR

          # Free up disk space first, before any other commands
          echo "Cleaning up disk space before updates..."
          df -h
          sudo yum clean all
          sudo rm -rf /var/cache/yum/*
          sudo rm -rf /home/ec2-user/go
          df -h
          
          # Update system and install essential packages
          sudo yum update -y
          sudo yum install -y git wget --allowerasing || sudo yum install -y git wget --skip-broken
          
          # Install Go if not present
          if ! command -v go &> /dev/null; then
            echo "Installing Go..."
            wget https://golang.org/dl/go1.24.0.linux-amd64.tar.gz -O /tmp/go.tar.gz
            sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf /tmp/go.tar.gz
            rm /tmp/go.tar.gz
          fi
          export PATH=$PATH:/usr/local/go/bin
          go version

          # Install Docker if not installed, and ensure it's running
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            sudo yum install -y docker
          fi
          
          echo "Ensuring Docker daemon is running..."
          sudo systemctl start docker
          sudo systemctl enable docker
          sudo usermod -aG docker ec2-user || true
          
          # Wait for Docker to be ready
          echo "Waiting for Docker daemon..."
          sleep 10
          sudo docker info

          # Clean up docker images from previous runs
          docker system prune -af || true

          # Install Docker Compose if not installed
          if ! command -v docker-compose &> /dev/null; then
            sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          
          # Remove existing directory completely and recreate
          rm -rf ~/ai-resume-backend
          mkdir -p ~/ai-resume-backend
          cd ~/ai-resume-backend
          
          # Clone the main branch of the repository using HTTPS (public repo)
          git clone -b main https://github.com/flychicken123/resume_back.git .
          
          # Check if clone was successful
          if [ ! -f "docker-compose.backend.yml" ]; then
            echo "Failed to clone repository or docker-compose file missing"
            exit 1
          fi
          
          # Download Go modules
          echo "Downloading Go modules..."
          go mod download

          # Build the Go binary on the host machine
          echo "Building Go binary on the EC2 instance..."
          go build -o main main.go

          # Create .env file for docker-compose with all required secrets
          cat > .env << EOF
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USER=${{ secrets.DB_USER }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          DB_SSLMODE=${{ secrets.DB_SSLMODE }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          GCP_PROJECT_ID=${{ secrets.GCP_PROJECT_ID }}
          GCP_PRIVATE_KEY_ID=${{ secrets.GCP_PRIVATE_KEY_ID }}
          GCP_PRIVATE_KEY='${{ secrets.GCP_PRIVATE_KEY }}'
          GCP_CLIENT_EMAIL=${{ secrets.GCP_CLIENT_EMAIL }}
          GCP_CLIENT_ID=${{ secrets.GCP_CLIENT_ID }}
          GCP_CLIENT_X509_CERT_URL=${{ secrets.GCP_CLIENT_X509_CERT_URL }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}
          EOF

          # SIMPLE DEPLOYMENT STRATEGY
          echo "üöÄ Starting deployment..."
          
          # Ensure network exists
          docker network create ai-resume-network || true
          
          # Build new image
          echo "üî® Building new backend image..."
          docker-compose -f docker-compose.backend.yml build --no-cache backend
          
          # Deploy with compose (this will replace the existing container)
          echo "üöÄ Deploying backend..."
          docker-compose -f docker-compose.backend.yml up -d
          
          # Wait for service to be ready
          echo "‚è≥ Waiting for service to be ready..."
          sleep 30
          
          # Check health
          echo "üè• Checking service health..."
          if curl -f http://localhost:8081/api/health > /dev/null 2>&1; then
            echo "‚úÖ Deployment successful - service is healthy!"
          else
            echo "‚ö†Ô∏è Service may still be starting up..."
          fi
          
          # Clean up
          docker system prune -f 
          
          # Final health check and smoke tests
          echo "üß™ Running comprehensive post-deployment tests..."
          sleep 15
          
          # Test health endpoint
          echo "Testing health endpoint..."
          if curl -f https://hihired.org/api/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed"
            exit 1
          fi
          
          # Test CORS headers
          echo "Testing CORS headers..."
          for EP in \
            "/api/auth/register" \
            "/api/auth/login" \
            "/api/experience/optimize" \
            "/api/resume/generate" \
            "/api/ai/summary"; do
            echo "Testing OPTIONS $EP"
            if curl -sS -i -X OPTIONS \
              -H "Origin: https://www.hihired.org" \
              -H "Access-Control-Request-Method: POST" \
              https://hihired.org$EP | grep -i "Access-Control-Allow-Origin"; then
              echo "‚úÖ CORS working for $EP"
            else
              echo "‚ö†Ô∏è CORS may not be working for $EP"
            fi
          done
          
          # Test API validation (should return proper error responses)
          echo "Testing API validation..."
          
          # Test invalid JSON should return 400
          echo "Testing invalid JSON handling..."
          response=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            -d '{"invalid": json}' \
            https://hihired.org/api/experience/optimize)
          if [ "$response" = "400" ]; then
            echo "‚úÖ Invalid JSON properly rejected"
          else
            echo "‚ö†Ô∏è Invalid JSON handling may not be working (got $response)"
          fi
          
          # Test missing content-type should return 400
          echo "Testing content-type validation..."
          response=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
            -d '{"test": "data"}' \
            https://hihired.org/api/experience/optimize)
          if [ "$response" = "400" ]; then
            echo "‚úÖ Content-Type validation working"
          else
            echo "‚ö†Ô∏è Content-Type validation may not be working (got $response)"
          fi
          
          echo "‚úÖ Deployment verification completed!"